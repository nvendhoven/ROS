\section{Creating a scheduler using \texttt{SysTick} }
The next step is creating a simple scheduler that can run periodic tasks. There are three different tasks the scheduler
should execute; blink a red, a yellow and a green LED for a given period after a 
given delay in ticks. Table \ref{tab:led_schedule} lists the requirements for these tasks.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
         & \textcolor{darkpink}{\textit{Toggle Period}} & \textcolor{darkpink}{\textit{Initial Delay}}\\
        \hline
        \textit{Red} & 200 & 100 \\
        \hline
        \textit{Yellow} & 500 & 200 \\
        \hline
        \textit{Green} & 750 & 300 \\
        \hline
    \end{tabular}
        
    \label{tab:led_schedule}
    \caption{Requirements blinking LEDs in Ticks}
\end{table}

The code that will be presented in Subsection \ref{subsec:schedule_task} is actually all located in the same file, namely \texttt{main.c}.
However, for the sake of clarity to the reader the code is split up into different listings which makes it easier to understand what piece of code is for what reason present.

\subsection{Scheduling Tasks}
\label{subsec:schedule_task}

Different tasks have different characteristics. Some housekeeping is required to map those characteristics to different functions (the behaviour a task is executing).
Those housekeeping goes into what's called a Task Control Block (TCB) \cite{SROS}, \cite{usosii}.
This TCB is defined in Listing \ref{lst:def_scheduler} at Line \ref{line:OS_tcb}.
Characteristics of a task is the function it executes (usually a pointer pointing to the function definition), the period time this function should be called, the amount of time it waits untill it is ready to be woken up and execute the function again as the new period arose and a state.
This state is defined in Line \ref{line:OS_state}.
Usually there are three states which is \texttt{STATE\_READY}, \texttt{STATE\_WAITING} and \texttt{STATE\_RUNNING} \cite{SROS}, \cite{usosii}.
Because this scheduler is almost too simple only \texttt{STATE\_READY} and \texttt{STATE\_WAITING} are necessary.

\begin{lstlisting}[style=CStyle, caption={Definition code where a state datatype and housekeeping datatype for tasks is made}, captionpos=b, label={lst:def_scheduler}, escapechar=@]
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include "register_def.h"

#include "inc\hw_memmap.h"
#include "inc\hw_gpio.h"
#include "inc\hw_apps_rcm.h"
#include "inc\hw_ocp_shared.h"

#include "blinky_tasks.h"

typedef enum
{
    STATE_READY = 0,
    STATE_WAITING
} OS_state; @\label{line:OS_state}@

typedef struct
{
    void (*task_function)(void);
    uint32_t tick_period;
    uint32_t ticks_used;
    OS_state state;
} OS_tcb;   @\label{line:OS_tcb}@

/* Global variables*/
OS_tcb tasks[8]; @\label{line:tasks_array}@
size_t amount_tasks = 0; @\label{line:amount_tasks}@
\end{lstlisting}

There are two global variables used in other parts within the same file.
\texttt{tasks} (Line \ref{line:tasks_array}) is an array that has space for 8 \texttt{OS\_tcb} objects which means a maxmimum of 8 tasks are schedulable by this scheduler unless a programer changes this number.
\texttt{amount\_tasks} keeps track howmuch stores \texttt{OS\_tcb} objects are in the \texttt{tasks} array.

\begin{lstlisting}[style=CStyle, caption={Task controllers}, captionpos=b, label={lst:task_control_functions}, escapechar=@]
void OS_add_task(void (*task_function)(void), uint32_t tick_period, uint32_t ticks_init_delay)
{
    tasks[amount_tasks].task_function = task_function;
    tasks[amount_tasks].tick_period = tick_period;
    tasks[amount_tasks].ticks_used = ticks_init_delay;
    tasks[amount_tasks++].state = STATE_WAITING;
}

void OS_run_ready_tasks()
{
    for(size_t idx = 0; idx != amount_tasks; idx++)
        if(tasks[idx].state == STATE_READY)
        {
            (*tasks[idx].task_function)();
            tasks[idx].state = STATE_WAITING;
        }
}
\end{lstlisting}

\begin{lstlisting}[style=CStyle, caption={Scheduler SysTick}, captionpos=b, label={lst:scheduler_systick}, escapechar=@]
void SystickHandler()
{
    for(size_t idx = 0; idx != amount_tasks; idx++)
    {
        tasks[idx].ticks_used -= 1;
        if(tasks[idx].ticks_used == 0)
        {
            if(tasks[idx].state == STATE_WAITING)
                tasks[idx].state = STATE_READY;
            tasks[idx].ticks_used = tasks[idx].tick_period;
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[style=CStyle, caption={Scheduler using SysTick Main function}, captionpos=b, label={lst:scheduler_systick_main}, escapechar=@]
int main(void)
{

    HWREG(ARCM_BASE + APPS_RCM_O_GPIO_A_CLK_GATING) = 0x01;

    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_9) = 0x60;
    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_10) = 0x60;
    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_11) = 0x60;

    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DIR) = 0x0E;
    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DATA + (0x0E << 2)) = 0x00;

    HWREG(NVIC_ST_CTRL) = 0x00;         /* Disable SysTick during setup */
    HWREG(NVIC_ST_RELOAD) = 0x13880;    /* 80 000 reload value (1000p/s interrupt) */
    HWREG(NVIC_ST_CURRENT) = 0x00;      /* Clear any flags and set current value to 0 */
    HWREG(NVIC_ST_CTRL) = 0x07;         /* Enable SysTick, Enable interrupt, CLK_SRC = System clock */

    OS_add_task(blinky_red, RED_PERIOD, 100);
    OS_add_task(blinky_yellow, YELLOW_PERIOD, 200);
    OS_add_task(blinky_green, GREEN_PERIOD, 300);

    while(1)
        OS_run_ready_tasks();

    return 0;
}
\end{lstlisting}

\subsection{Blinky LED}
\begin{lstlisting}[style=CStyle, caption={Toggling LED tasks according to Table \ref{tab:led_schedule} }, captionpos=b, label={lst:led_tasks}, escapechar=@]
#define RED_PERIOD      200
#define YELLOW_PERIOD   500
#define GREEN_PERIOD    750

void blinky_red(void)
{
    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DATA + (0x02 << 2)) ^= 0x02;
}

void blinky_yellow(void)
{
    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DATA + (0x04 << 2)) ^= 0x04;
}

void blinky_green(void)
{
    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DATA + (0x08 << 2)) ^= 0x08;
}
\end{lstlisting}



\section{Replace busy-wait techniques using the \texttt{SysTick} timer}

Using a busy-wait technique to delay for a certain amount of time is not efficient.
Wasting \enquote{expensive} CPU cycles should be avoided whenever possible.
This is where hardware timers comes in.
Hardware timers decrement or increment a given value at a certain frequency and generates a signal if the value reached a treshold (this could be in the form of underflow or overflow aswell as reaching a certain value where 0 is the most common one).
This chapter describes the \texttt{SysTick} hardware timer.

\subsection{\texttt{SysTick} timer and interrupt using DRM}

As mentioned in the previous section, when one uses the DRM programming technique it is important that the programmer knows the microcontroller really well.
Understanding the different Special Function Registers (SFR) related to the hardware module one wants to use is a consequence.
The three SFR related to \texttt{SysTick} are described below.

\begin{figure}[H]
\centering

\begin{bytefield}[endianness=big, bitwidth=3.0em]{30}
\bitheader[lsb=2]{16-31} \\
    \bitbox{15}{\tiny Reserved} &
    \colorbitbox{celadon}{1}{\tiny COUNT} \\ [3ex]
\bitheader[lsb=-14]{0-15} \\
    \bitbox{13}{\tiny Reserved}
    \colorbitbox{celadon}{1}{\tiny CLK\_SRC}
    \colorbitbox{celadon}{1}{\tiny INTEN}
    \colorbitbox{celadon}{1}{\tiny ENABLE}
\end{bytefield}

\caption{\texttt{STCTRL} register for the CC3220s}
\label{fig:stctrl}

\end{figure}

First, there is \texttt{STCTRL} (\texttt{SysTick} Control Register) which enables the \texttt{SysTick} features \cite{CC3220s_reference_manual}.
Bit 0 (Figure \ref{fig:stctrl}) enables the \texttt{SysTick} module if this bit is set or disables the \texttt{SysTick} module if this bit is cleared.
The \texttt{SysTick} module will generate an interrupt only if bit 1 is set.
The clock source fed into the \texttt{SysTick} module can be the system clock if bit 3 is set or a precision internal oscillator if bit 3 is cleared \cite{CC3220s_reference_manual}.


\begin{figure}[H]
\centering

\begin{bytefield}[endianness=big, bitwidth=3.0em]{30}
\bitheader[lsb=2]{16-31} \\
    \bitbox{8}{\tiny Reserved} &
    \colorbitbox{celadon}{8}{\tiny RELOAD} \\ [3ex]
\bitheader[lsb=-14]{0-15} \\
    \colorbitbox{celadon}{16}{\tiny RELOAD}
\end{bytefield}

\caption{\texttt{STRELOAD} register for the CC3220s}
\label{fig:streload}

\end{figure}

Second, there is \texttt{STRELOAD} register (Figure \ref{fig:streload}) which stores the constant that should be loaded to the \texttt{STCURRENT} register if the previous value reached value 0.
One should keep in mind that if the desired behaviour is an interrupt or a flag every $x$ ticks, one should store $x - 1$ ticks in this register.
This is because the \texttt{RELOAD} value is copied to \texttt{STCURRENT} current register if 0 is reached (so not one tick after zero).

\begin{figure}[H]
\centering

\begin{bytefield}[endianness=big, bitwidth=3.0em]{30}
\bitheader[lsb=2]{16-31} \\
    \bitbox{8}{\tiny Reserved} &
    \colorbitbox{celadon}{8}{\tiny CURRENT} \\ [3ex]
\bitheader[lsb=-14]{0-15} \\
    \colorbitbox{celadon}{16}{\tiny CURRENT}
\end{bytefield}

\caption{\texttt{STCURRENT} register for the CC3220s}
\label{fig:stcurrent}

\end{figure}

The last register is the \texttt{STCURRENT} register.
This register holds the current value being decremented.
An important detail is that the \texttt{CURRENT} field is write-clear behaviour.
This means that writing any value to this field clears the register and the \texttt{COUNT} bit of the \texttt{STCTRL} register \cite{CC3220s_reference_manual}.

\newpage
\begin{lstlisting}[style=CStyle, caption={Toggling LEDs according to Table \ref{tab:led_scheme} using DRM programming technique}, captionpos=b, label={lst:led_systick_drm}, escapechar=@]
#include <stdint.h>
#include <stddef.h>
#include "register_def.h"

#include "inc\hw_memmap.h"
#include "inc\hw_gpio.h"
#include "inc\hw_apps_rcm.h"
#include "inc\hw_ocp_shared.h"

static volatile _Bool flag_led_update;  @\label{line:drm_systick_flag}@

void SysTickHandler()   @\label{line:drm_systick_irq}@
{
    static int tick_count = 0;
    flag_led_update = tick_count == 1000 ? 1 : 0;   @\label{line:drm_systick_set_flag}@
    tick_count = (tick_count+1) % (1000 + 1);       @\label{line:drm_systick_inc}@
}

int main(void)
{

    /* Init SysTick */
    HWREG(NVIC_ST_CTRL) = 0x00;         // Disable SysTick during setup     @\label{line:drm_systick_disable}@
    HWREG(NVIC_ST_RELOAD) = 79999;      // Get every millisecond an interrupt (80 000 - 1)  @\label{line:drm_systick_reload}@
    HWREG(NVIC_ST_CURRENT) = 0x00;      // Clear any flags and set current value to 0       @\label{line:drm_systick_current}@
    HWREG(NVIC_ST_CTRL) = 0x07;         // Enable SysTick, Enable interrupt, CLK_SRC = System clock @\label{line:drm_systick_enabe}@

    /* Init LEDS */
    HWREG(ARCM_BASE + APPS_RCM_O_GPIO_A_CLK_GATING) = 0x01;

    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_9) = 0x60;
    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_10) = 0x60;
    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_11) = 0x60;

    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DIR) = 0x0E;
    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DATA + (0x0E << 2)) = 0x00;

    unsigned int index = 0;

    while(1)
    {
        if(!flag_led_update)
            continue;

        HWREG(GPIOA1_BASE + GPIO_O_GPIO_DATA + (0x0E << 2)) = index;
        index = (index + 1) % 16;
        flag_led_update = 0;
    }

    return 0;
}
\end{lstlisting}

Listing \ref{lst:led_systick_drm} shows the programming source code to toggle the LEDs using the \texttt{SysTick} timer module to delay the correct amount of time.
Line \ref{line:drm_systick_flag} contains a shared variable which is used as a flag. If this variable is set the main loop should toggle the LEDs in the next row in Table \ref{tab:led_scheme}. If this variable is not set then the main loop has to do nothing.
Line \ref{line:drm_systick_irq} is the entry point for the \texttt{SysTick} event handler.
Every time a \texttt{SysTick} interrupt occurs this piece of event handler code is executed.
There should be a delay of 1 second between every row in Table \ref{tab:led_scheme}. Since the \texttt{SysTick} interrupt is executed every 1 millisecond the code should execute the \texttt{SysTick} handler 1000 times before updating the shared variable.
\texttt{tick\_count} takes care of that. This static variable does not lose its content between two execution runs of the event handler.
Every interrupt this variable is incremented (Line \ref{line:drm_systick_inc}) and when its incremented 1000 times the shared variable is set (Line \ref{line:drm_systick_set_flag}). 

\newpage
After booting, the first thing done is disabling the \texttt{SysTick} module (Line \ref{line:drm_systick_disable}) by setting all bits in the \texttt{STCTRL} register to 0 (including the \texttt{\scriptsize ENABLE} bit).
Then it loads the reset value $80 000 - 1$ into the \texttt{STRELOAD} register (Line \ref{line:drm_systick_reload}) and clears the current value and any flags already set (Line \ref{line:drm_systick_current}).
\texttt{\scriptsize ENABLE}, \texttt{\scriptsize INTEN} and \texttt{\scriptsize CLK\_SRC} bits in the \texttt{STCTRL} register (Figure \ref{fig:stctrl}) are set by writing $00000111_2$ or $0x07_{16}$ to this register.
From this point in the code the \texttt{SysTick} module is enabled and decrementing.

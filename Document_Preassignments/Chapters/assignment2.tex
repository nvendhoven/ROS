\section{Replace busy-wait techniques using the \texttt{SysTick} timer}

Using a busy-wait technique to delay for a certain amount of time is not efficient.
Wasting \enquote{expensive} CPU cycles should be avoided whenever possible.
This is where hardware timers comes in.
Hardware timers decrement or increment a given value at a certain frequency and generates a signal if the value reached a treshold (this could be in the form of underflow or overflow aswell as reaching a certain value where 0 is the most common one).
This chapter describes the \texttt{SysTick} hardware timer.

\subsection{\texttt{SysTick} timer and interrupt using DRM}

As mentioned in the previous section, when one uses the DRM programming technique it is important that the programmer knows the microcontroller really well.
Understanding the different Special Function Registers (SFR) related to the hardware module one wants to use is a consequence.
The three SFR related to \texttt{SysTick} are described below.

\begin{figure}[H]
\centering

\begin{bytefield}[endianness=big, bitwidth=3.0em]{30}
\bitheader[lsb=2]{16-31} \\
    \bitbox{15}{\tiny Reserved} &
    \colorbitbox{celadon}{1}{\tiny COUNT} \\ [3ex]
\bitheader[lsb=-14]{0-15} \\
    \bitbox{13}{\tiny Reserved}
    \colorbitbox{celadon}{1}{\tiny CLK\_SRC}
    \colorbitbox{celadon}{1}{\tiny INTEN}
    \colorbitbox{celadon}{1}{\tiny ENABLE}
\end{bytefield}

\caption{\texttt{STCTRL} register for the CC3220s}
\label{fig:stctrl}

\end{figure}

First, there is \texttt{STCTRL} (\texttt{SysTick} Control Register) which enables the \texttt{SysTick} features \cite{CC3220s_reference_manual}.
Bit 0 (Figure \ref{fig:stctrl}) enables the \texttt{SysTick} module if this bit is set or disables the \texttt{SysTick} module if this bit is cleared.
The \texttt{SysTick} module will generate an interrupt only if bit 1 is set.
The clock source fed into the \texttt{SysTick} module can be the system clock if bit 3 is set or a precision internal oscillator if bit 3 is cleared \cite{CC3220s_reference_manual}.


\begin{figure}[H]
\centering

\begin{bytefield}[endianness=big, bitwidth=3.0em]{30}
\bitheader[lsb=2]{16-31} \\
    \bitbox{8}{\tiny Reserved} &
    \colorbitbox{celadon}{8}{\tiny RELOAD} \\ [3ex]
\bitheader[lsb=-14]{0-15} \\
    \colorbitbox{celadon}{16}{\tiny RELOAD}
\end{bytefield}

\caption{\texttt{STRELOAD} register for the CC3220s}
\label{fig:streload}

\end{figure}

Second, there is \texttt{STRELOAD} register (Figure \ref{fig:streload}) which stores the constant that should be loaded to the \texttt{STCURRENT} register if the previous value reached value 0.
One should keep in mind that if the desired behaviour is an interrupt or a flag every $x$ ticks, one should store $x - 1$ ticks in this register.
This is because the \texttt{RELOAD} value is copied to \texttt{STCURRENT} current register if 0 is reached (so not one tick after zero).

\begin{figure}[H]
\centering

\begin{bytefield}[endianness=big, bitwidth=3.0em]{30}
\bitheader[lsb=2]{16-31} \\
    \bitbox{8}{\tiny Reserved} &
    \colorbitbox{celadon}{8}{\tiny CURRENT} \\ [3ex]
\bitheader[lsb=-14]{0-15} \\
    \colorbitbox{celadon}{16}{\tiny CURRENT}
\end{bytefield}

\caption{\texttt{STCURRENT} register for the CC3220s}
\label{fig:stcurrent}

\end{figure}

The last register is the \texttt{STCURRENT} register.
This register holds the current value being decremented.
An important detail is that the \texttt{CURRENT} field is write-clear behaviour.
This means that writing any value to this field clears the register and the \texttt{COUNT} bit of the \texttt{STCTRL} register \cite{CC3220s_reference_manual}.

\newpage
\begin{lstlisting}[style=CStyle, caption={Toggling LEDs according to Table \ref{tab:led_scheme} using DRM programming technique}, captionpos=b, label={lst:led_systick_drm}, escapechar=@]
#include <stdint.h>
#include <stddef.h>
#include "register_def.h"

#include "inc\hw_memmap.h"
#include "inc\hw_gpio.h"
#include "inc\hw_apps_rcm.h"
#include "inc\hw_ocp_shared.h"

static volatile _Bool flag_led_update;  @\label{line:drm_systick_flag}@

void SysTickHandler()   @\label{line:drm_systick_irq}@
{
    static int tick_count = 0;
    flag_led_update = tick_count == 1000 ? 1 : 0;   @\label{line:drm_systick_set_flag}@
    tick_count = (tick_count+1) % (1000 + 1);       @\label{line:drm_systick_inc}@
}

int main(void)
{

    /* Init SysTick */
    HWREG(NVIC_ST_CTRL) = 0x00;         // Disable SysTick during setup     @\label{line:drm_systick_disable}@
    HWREG(NVIC_ST_RELOAD) = 79999;      // Get every millisecond an interrupt (80 000 - 1)  @\label{line:drm_systick_reload}@
    HWREG(NVIC_ST_CURRENT) = 0x00;      // Clear any flags and set current value to 0       @\label{line:drm_systick_current}@
    HWREG(NVIC_ST_CTRL) = 0x07;         // Enable SysTick, Enable interrupt, CLK_SRC = System clock @\label{line:drm_systick_enabe}@

    /* Init LEDS */
    HWREG(ARCM_BASE + APPS_RCM_O_GPIO_A_CLK_GATING) = 0x01;     @\label{line:drm_systick_gpio_enable}@

    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_9) = 0x60; @\label{line:drm_systick_pad_one}@
    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_10) = 0x60;
    HWREG(OCP_SHARED_BASE + OCP_SHARED_O_GPIO_PAD_CONFIG_11) = 0x60;@\label{line:drm_systick_pad_three}@

    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DIR) = 0x0E;            @\label{line:drm_systick_dir}@
    HWREG(GPIOA1_BASE + GPIO_O_GPIO_DATA + (0x0E << 2)) = 0x00; @\label{line:drm_systick_init_data}@

    unsigned int index = 0;

    while(1)
    {
        if(!flag_led_update)        @\label{line:drm_systick_is_update}@
            continue;               @\label{line:drm_systick_continue}@

        HWREG(GPIOA1_BASE + GPIO_O_GPIO_DATA + (0x0E << 2)) = index;    @\label{line:drm_systick_set_led}@
        index = (index + 1) % 16;                                       @\label{line:drm_systick_inc_index}@
        flag_led_update = 0;                                            @\label{line:drm_systick_clear_flag}@
    }

    return 0;
}
\end{lstlisting}

Listing \ref{lst:led_systick_drm} shows the programming source code to toggle the LEDs using the \texttt{SysTick} timer module to delay the correct amount of time.
Line \ref{line:drm_systick_flag} contains a shared variable which is used as a flag. If this variable is set the main loop should toggle the LEDs in the next row in Table \ref{tab:led_scheme}. If this variable is not set then the main loop has to do nothing.
Line \ref{line:drm_systick_irq} is the entry point for the \texttt{SysTick} event handler.
Every time a \texttt{SysTick} interrupt occurs this piece of event handler code is executed.
There should be a delay of 1 second between every row in Table \ref{tab:led_scheme}. Since the \texttt{SysTick} interrupt is executed every 1 millisecond the code should execute the \texttt{SysTick} handler 1000 times before updating the shared variable.
\texttt{tick\_count} takes care of that. This static variable does not lose its content between two execution runs of the event handler.
Every interrupt this variable is incremented (Line \ref{line:drm_systick_inc}) and when its incremented 1000 times the shared variable is set (Line \ref{line:drm_systick_set_flag}). 

\newpage
After booting, the first thing done is disabling the \texttt{SysTick} module (Line \ref{line:drm_systick_disable}) by setting all bits in the \texttt{STCTRL} register to 0 (including the \texttt{\scriptsize ENABLE} bit).
Then it loads the reset value $80 000 - 1$ into the \texttt{STRELOAD} register (Line \ref{line:drm_systick_reload}) and clears the current value and any flags already set (Line \ref{line:drm_systick_current}).
\texttt{\scriptsize ENABLE}, \texttt{\scriptsize INTEN} and \texttt{\scriptsize CLK\_SRC} bits in the \texttt{STCTRL} register (Figure \ref{fig:stctrl}) are set by writing $00000111_2$ or $0x07_{16}$ to this register.
From this point in the code the \texttt{SysTick} module is enabled and decrementing.\newline

What now follows is a description of the main code. 
This is almost identical to the code described in Section \ref{subsec:led_drm}.
The registers related to GPIO can be found in that section aswell.
Line \ref{line:drm_systick_gpio_enable} in Listing \ref{lst:led_systick_drm} enables the GPIOA peripheral.
Line \ref{line:drm_systick_pad_one} up to and including Line \ref{line:drm_systick_pad_three} configures the behaviour of GPIO pin 9, GPIO pin 10 and GPIO pin 11. Those pins are configured to have a maximum current usage of 6 mA.
Line \ref{line:drm_systick_dir} configures GPIO pin 9, GPIO pin 10 and GPIO pin 11  as an output pin.
Line \ref{line:drm_systick_init_data} turns those GPIO pins off according to first row of Table \ref{tab:led_scheme}. \newline

The following code is executed in an endless loop.
Line \ref{line:drm_systick_is_update} and Line \ref{line:drm_systick_continue} were not present in Section \ref{subsec:led_drm}.
Line \ref{line:drm_systick_is_update} checks if the shared variable \texttt{flag\_led\_update} is set by the \texttt{SysTick} event handler. It it is not Line \ref{line:drm_systick_continue} is executed and the check will be executed again.
If it is set then Line \ref{line:drm_systick_set_led} up to and including Line \ref{line:drm_systick_clear_flag} will be executed.
Line \ref{line:drm_systick_set_led} writes the new sequence of LEDs to the GPIO pins.
Line \ref{line:drm_systick_inc_index} increments the sequence so the next row in Table \ref{tab:led_scheme} will be set next time the shared variable is set.
Line \ref{line:drm_systick_clear_flag} clears the flag so the next iteration of the loop won't update the LEDs again.

The reader may wonder how the microcontroller knows which function should be executed on a \texttt{SysTick} interrupt.
This is done using the vector table. This vector table contains different function names for different kind of interrupts (Listing \ref{lst:systick_vector_table_min}).
Because the function definition \texttt{SysTickHandler} is in \texttt{main.c} we declare it as extern so the compiler will not fail and the linker will search for the external references in a later stage of the compilation process.

\begin{lstlisting}[style=CStyle, caption={Part of \texttt{cc3220\_startup\_ccs.c} which contains a part of the vector table}, captionpos=b, label={lst:systick_vector_table_min}, escapechar=@]
......
......
extern void SysTickHandler();
......
......

void (* const resetVectors[43])(void) =
{
    (void (*)(void))((unsigned long)&__STACK_END),
                                         // The initial stack pointer
    resetISR,                            // The reset handler
    nmiISR,                              // The NMI handler
    faultISR,                            // The hard fault handler
    defaultHandler,                      // The MPU fault handler
    busFaultHandler,                     // The bus fault handler
    defaultHandler,                      // The usage fault handler
    0,                                   // Reserved
    0,                                   // Reserved
    0,                                   // Reserved
    0,                                   // Reserved
    defaultHandler,                     // SVCall handler
    defaultHandler,                      // Debug monitor handler
    0,                                   // Reserved
    defaultHandler,                      // The PendSV handler
    SysTickHandler,                      // The SysTick handler
    defaultHandler,                      // GPIO Port A0
    defaultHandler,                      // GPIO Port A1
    defaultHandler,                      // GPIO Port A2
    defaultHandler,                      // GPIO Port A3
    ......
    ......
}

\end{lstlisting}

For more information about exception, interrupts and the vector table, see Appendix \ref{subsec:appendix_vector}.
